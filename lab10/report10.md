# Отчёт по лабораторной работе №10

### Цель работы
Изучить основы программирования в оболочке ОС UNIX/Linux, научиться писать небольшие командные файлы

### Ход выполнения работы

#### 1. Создадим исполняемый файл backup.sh, который будет создавать копию самого себя с архивацией
![photo1](https://sun9-36.userapi.com/s/v1/if2/9xk0Ubk4XOJzm8TBaSXlBJT7SDcAAJ3nEYzpsP1SA1A-GfFhIncTVlSiM4B0JPlpfBcYq9aTzKs8WNZQXx6uwxYP.jpg?size=403x298&quality=96&type=album)
![photo2](https://sun9-46.userapi.com/s/v1/if2/NZf-ehl5gPxEiMzEGw7lVgxkL8sSmDiDJkA9kCHqvF3nyTrOQ780IMgN-M1-J6XeffJYyQLTfAKaHFdnkjAfD8vg.jpg?size=337x112&quality=96&type=album)

#### 2. Создадим исполняемый файл progr.sh, который будет обрабатывать аргументы из командной строки и последовательно распечатывать их
![photo3](https://sun9-81.userapi.com/s/v1/if2/-QHAJpmfjwk_ONE9YGVF9zBCWtOVqw0i9UHjyDbpjvgqkkuNL9JizVhs9TFN92B6T_yRZkbLRuPAtjt7YuXstoPl.jpg?size=401x296&quality=96&type=album)
![photo4](https://sun9-67.userapi.com/s/v1/if2/vl4g5JuULPc6iAhrdBFJVPTbo4r9di13a2_mPUeiWENjqg6wPz2i-CQNPeFy8x-TAgWzIkgV2OA7dsyDfCRxTkdK.jpg?size=199x68&quality=96&type=album)

#### 3. Создадим исполняемый файл not_ls.sh, который будет исполнять задачи команды ls, то есть выводить на экран содержимое каталога
![photo5](https://sun9-59.userapi.com/s/v1/if2/-mnCIiPf4h5zqSXm2zC2_qzHUHSWNJWwVjIj1AGWvKTBILIjDPOHuanPSfvcHvmqkXvL0ETgPFxmIW7htI3Djsew.jpg?size=400x298&quality=96&type=album)
![photo6](https://sun9-74.userapi.com/s/v1/if2/Yfp5ovskQYttjtWRFQgQbWpcd0f1ksFivklY3l2-tA4uVp4_Pa5PKkoEwUdj9UYZ7G7VE9VUsWURoyJ4JQ8wrCON.jpg?size=403x200&quality=96&type=album)

#### 4. Создадим исполняемый файл format.sh, который будет выводить на экран количество файлов заданного формата в заданном каталоге
![photo7](https://sun9-79.userapi.com/s/v1/if2/YfwIHNGrRAuHp1TH2qBfdFoP6gwZyU4OOwP8s_wGovAf9WbLIlnvtrxqviJblrm0SyXjEP8v_uAOOzV6qvfnTf5X.jpg?size=403x296&quality=96&type=album)
![photo8](https://sun9-81.userapi.com/s/v1/if2/HUmrDW4HM_yKZ3AEyXjkY9TuQ17Kvg0-sJLGoLwajuXBJu7tusGMQwhRREJ76nqow4fTNfgpwFKs5xA_jIG99hUl.jpg?size=405x158&quality=96&type=album)

### Выводы
Я изучил основы программирования в оболочке ОС UNIX/Linux, а также научился писать небольшие командные файлы

### Ответы на контрольные вопросы:

#### 1.
Командный процессор (командная оболочка, интерпретатор команд shell) − это программа, позволяющая пользователю взаимодействовать с операционной системой компьютера. В операционных системах типа UNIX/Linux наиболее часто используются следующие реализации командных оболочек:

оболочка Борна (Bourneshellили sh) − стандартная командная оболочка UNIX/Linux, содержащая базовый, но при этом полный набор функций;

С-оболочка (или csh) −надстройка на оболочкой Борна, использующая Сподобный синтаксис команд с возможностью сохранения истории выполнения команд;

Оболочка Корна (или ksh) − напоминает оболочку С, но операторы управления программой совместимы с операторами оболочки Борна;

BASH − сокращение от BourneAgainShell(опять оболочка Борна), в основе своей совмещает свойства оболочек С и Корна (разработка компании FreeSoftwareFoundation).
#### 2.
POSIX (Portable Operating System Interface for Computer Environments ) − набор стандартов описания интерфейсов взаимодействия операционной системы и прикладных программ. Стандарты POSIX разработаны комитетом IEEE (Institute of Electricaland Electronics Engineers) для обеспечения совместимости различных UNIX/Linux подобных операционных систем и переносимости прикладных программ на уровне исходного кода. POSIX - совместимые оболочки разработаны на базе оболочки Корна.

#### 3.
Командный процессор bash обеспечивает возможность использования переменных типа строка символов. Имена переменных могут быть выбраны пользователем. Пользователь имеет возможность присвоить переменной значение некоторой строки символов. Например, команда «mark=/usr/andy/bin» присваивает значение строки символов /usr/andy/bin переменной mark типа строка символов. Значение, присвоенное некоторой переменной, может быть впоследствии использовано. Для этого в соответствующем месте командной строки должно быть употреблено имя этой переменной, которому предшествует метасимвол Напримеркоманда«{mark}» переместит файл afile из текущего каталога в каталог с абсолютным полным именем /usr/andy/bin. Оболочка bash позволяет работать с массивами. Для создания массива используется команда setс флагом -A. За флагом следует имя переменной, а затем список значений, разделённых пробелами. Например, «set -Astates Delaware Michigan "New Jersey"». Далее можно сделать добавление в массив, например, states[49]=Alaska. Индексация массивов начинается с нулевого элемента.

#### 4.
Оболочка bash поддерживает встроенные арифметические функции. Команда let является показателем того, что последующие аргументы представляют собой выражение, подлежащее вычислению. Простейшее выражение − это единичный терм (term), обычно целочисленный. Команда let берет два операнда и присваивает их переменной. Команда read позволяет читать значения переменных со стандартного ввода: «echo "Please enter Month and Day of Birth ?"» «read mon day trash». В переменные monи day будут считаны соответствующие значения, введённые с клавиатуры, а переменная trash нужна для того, чтобы отобрать всю избыточно введённую информацию и игнорировать её.

#### 5.
В языке программирования bash можно применять такие арифметические операции как сложение (+), вычитание (-), умножение (*), целочисленное деление (/) и целочисленный остаток от деления (%).

#### 6.
В (( ))можно записывать условия оболочки bash, а также внутри двойных скобок можно вычислять арифметические выражения и возвращать результат.

#### 7.
Стандартные переменные:

PATH: значением данной переменной является список каталогов, в которых командный процессор осуществляет поиск программы или команды, указанной в командной строке, в том случае, если указанное имя программы или команды не содержит ни одного символа /. Если имя команды содержит хотя бы один символ /, то последовательность поиска, предписываемая значением переменной PATH, нарушается. В этом случае в зависимости от того, является имя команды абсолютным или относительным, поиск начинается соответственно от корневогоили текущего каталога.

PS1 и PS2: эти переменные предназначены для отображения промптера командного процессора. PS1 −
это промптер командного процессора, по умолчанию его значение равно символу $ или #. Если какая-то интерактивная программа, запущенная командным процессором, требует ввода, то используется промптер PS2. Он по умолчанию имеет значение символа >.

HOME: имя домашнего каталога пользователя. Если команда cdвводится без аргументов, то происходит переход в каталог,указанный в этой переменной.

IFS:последовательность символов, являющихся разделителями в командной строке, например, пробел, табуляция и перевод строки (newline).

MAIL:командный процессор каждый раз перед выводом на экран промптера проверяет содержимое файла, имя которого указано в этой переменной, и если содержимое этого файла изменилось с момента последнего ввода из него, то перед тем как вывести на терминал промптер, командный процессор выводит на терминал сообщение Youhavemail(у Вас есть почта).

TERM: тип используемого терминала.

LOGNAME: содержит регистрационное имя пользователя, которое устанавливается автоматически при входе в систему.

#### 8.
Такие символы, как ' < > * ? | " &, являются метасимволами и имеют для командного процессора специальный смысл.

#### 9.
Снятие специального смысла с метасимвола называется экранированием мета символа. Экранирование может быть осуществлено с помощью предшествующего мета символу символа , который, в свою очередь, является мета символом. Для экранирования группы метасимволов нужно заключить её в одинарные кавычки. Строка, заключённая в двойные кавычки, экранирует все метасимволы, кроме $, ' , , ". Например, –echo* выведет на экран символ , –echoab’|’cd выведет на экран строку ab|*cd.

#### 10. 
Последовательность команд может быть помещена в текстовый файл. Такой файл называется командным. Далее этот файл можно выполнить по команде: «bash командный_файл [аргументы]». Чтобы не вводить каждый раз последовательности символов bash, необходимо изменить код защиты этого командного файла, обеспечив доступ к этому файлу по выполнению. Это может быть сделано с помощью команды «chmod +x имя_файла». Теперь можно вызывать свой командный файл на выполнение, просто вводя его имя с терминала так, как будтоон является выполняемой программой. Командный процессор распознает, что в Вашем файле на самом деле хранится не выполняемая программа, а программа, написанная на языке программирования оболочки, и осуществить её интерпретацию.

#### 11. 
Группу команд можно объединить в функцию. Для этого существует ключевое слово function, после которого следует имя функции и список команд, заключённых в фигурные скобки. Удалить функцию можно с помощью команды unsetcфлагом -f.

#### 12.
Чтобы выяснить, является ли файл каталогом или обычным файлом, необходимо воспользоваться командами «test-f [путь до файла]» (для проверки, является ли обычным файлом) и «test -d[путь до файла]» (для проверки, является ли каталогом).

#### 13.
Команду «set» можно использовать для вывода списка переменных окружения. В системах Ubuntu и Debia nкоманда «set» также выведет список функций командной оболочки после списка переменных командной оболочки. Поэтому для ознакомления со всеми элементами списка переменных окружения при работе с данными системами рекомендуется использовать команду «set| more». Команда «typeset» предназначена для наложения ограничений на переменные. Команду «unset» следует использовать для удаления переменной из окружения командной оболочки.

#### 14.
При вызове командного файла на выполнение параметры ему могут быть переданы точно таким же образом, как и выполняемой программе. С точки зрения командного файла эти параметры являются позиционными. Символ $ является метасимволом командного процессора. Он используется, в частности, для ссылки на параметры, точнее, для получения их значений в командном файле. В командный файл можно передать до девяти параметров. При использовании где-либо в командном файле комбинации символов $i, где 0 < i< 10, вместо неё будет осуществлена подстановка значения параметра с порядковым номером i, т.е. аргумента командного файла с порядковым номером i. Использование комбинации символов $0 приводит к подстановке вместо неё имени
данного командного файла.

#### 15. 
Специальные переменные:

$* −отображается вся командная строка или параметры оболочки;

$? −код завершения последней выполненной команды;

$$ −уникальный идентификатор процесса, в рамках которого выполняется командный процессор;

$! −номер процесса, в рамках которого выполняется последняя вызванная на выполнение в командном режиме команда;

$- −значение флагов командного процессора;

${#} −возвращает целое число −количествослов, которые были результатом $;

${#name} −возвращает целое значение длины строки в переменной name;

${name[n]} −обращение к n-му элементу массива;

${name[*]} −перечисляет все элементы массива, разделённые пробелом;

${name[@]} −то же самое, но позволяет учитывать символы пробелы в самих переменных;

${name:-value} −если значение переменной name не определено, то оно будет заменено на указанное value;

${name:value} −проверяется факт существования переменной;

${name=value} −если name не определено, то ему присваивается значение value;

${name?value} −останавливает выполнение, если имя переменной не определено, и выводит value как сообщение об ошибке;

${name+value} −это выражение работает противоположно ${name-value}. Если переменная определена, то подставляется value;

${name#pattern} −представляет значение переменной name с удалённым самым коротким левым образцом (pattern);

${#name[*]} и ${#name[@]} −эти выражения возвращают количество элементов в массиве name.
